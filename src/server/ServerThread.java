/*
 * This class is the class where the logic for the server is implemented and 
 * the client is connected to a thread specific to itself
 */
package server;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.security.PublicKey;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Semaphore;

// TODO: Create something so once a client is in a room the main server actually sends messages to all the clients connected to the room.

public class ServerThread extends Server implements Runnable{
	private Random random;
	private String name;
	private Socket cs;
	private char[] leters= {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	private int[] numbers= {0,1,2,3,4,5,6,7,8,9,0};
	private List<Room>rooms;
	private Semaphore roomCreation;
	ClientStorage client;
	private PublicKey publicKey;
	private PublicKey clientPublicKey;
	
	public ServerThread(String name,Socket cs,List<Room>rooms,Semaphore roomCreation) throws IOException {
		this.name=name;
		this.cs=cs;
		this.rooms=rooms;
		this.roomCreation=roomCreation;
	}

	
	
	@Override
	public void run(){
	    try{
	        System.out.println("Client online");
	
	        DataInputStream in = new DataInputStream(cs.getInputStream());
	        DataOutputStream out = new DataOutputStream(cs.getOutputStream());
	    	ObjectOutputStream OOut= new ObjectOutputStream(cs.getOutputStream());
			ObjectInputStream OIn= new ObjectInputStream(cs.getInputStream());
	        
			OOut.writeObject(publicKey);
			clientPublicKey = (PublicKey) OIn.readObject();
	        //Sends a message to the client using it's out tunnel
	        out.writeUTF("Request recieved and accepted by "+ name);
//	        need an in where the client gives the server the public key with all it's details
	        String clientName = in.readUTF();
	        this.client=new ClientStorage(clientName, out, in, clientPublicKey);
	        
	        while(true) {
	        		
	        		if(checkClient())
	        			broadcast();
	        	
		            String message = in.readUTF();
		            String[] parts=message.split(",");
		            action(parts,out);
		        if(message.equalsIgnoreCase("/disconnect")) break;
	        }
	        cs.close();//Closes the connection to the client
	    } catch(Exception e){
	        e.printStackTrace();
	    }
	}
	
	/*
	 * pre:
	 * post: Generates an random alphanumerical ID to be assigned to the rooms
	 */
	private String idGenerator() {
		String identifier="";
		for(int i=0;i<6;i++) {
			boolean selector=random.nextBoolean();
			if(selector) {
				int index=random.nextInt(0, numbers.length+1);
				identifier+=numbers[index];
			}else {
				int index=random.nextInt(0, leters.length+1);
				identifier+=leters[index];
			}
		}
		return identifier;
	}
	
	public void action(String[] parts,DataOutputStream out) throws IOException, InterruptedException{
		
		switch (parts[0]) {
			case "1": // join room
				String[] roomDetails = parts[1].split("#");
				try {
					if(!rooms.isEmpty()) {
						for(Room room:rooms)
							if(room.getName().equals(roomDetails[0]) || room.getId().equals(roomDetails[1])) {
								roomCreation.acquire();
								room.getConnectedClients().add(client);
								roomCreation.release();
							}
					}
				} catch (IndexOutOfBoundsException ioobe) {
					if(roomDetails[1]==null)
						out.writeUTF("No room ID provided please keep in mind to separate the room name and ID with '#'\n");
					else 
						out.writeUTF("An error ocurred while processing your request\n");
				}
				break;
				
			case "2": // create room
				if(parts[2]!=null) 
					rooms.add(new Room(parts[1], parts[2], checkIdValidity()));
				else 
					rooms.add(new Room(parts[1], checkIdValidity()));
				break;
			
			case "3": // show rooms
				String roomList="This are all the rooms available:\n";
				for(Room room:rooms)
					roomList+="~ "+room.getName()+"#"+room.getId()+"\n";
					out.writeUTF(roomList);
				break;
				
			case "4": //disconnect client
				
				break;

			default:
				System.out.println("Something unexpected happened while processing your request");
		}
	}
	
	/*
	 * pre:
	 * post: Checks if the Id generated by idGenerator() is valid if it's valid it returns it,
	 * if not it calls again the generator until it gets a valid ID.
	 */
	public String checkIdValidity() {
		boolean validId=false;
		String id="";
		
		while(!validId) {
			int count=0;
			id=idGenerator();
		
			if(!rooms.isEmpty())
				for(Room room:rooms)
					if(id.equals(room.getId()))
						count++;
			
			if(count==0)
				validId=true;
		}
		
		return id;
	}

	/*
	 * pre:
	 * post: This checks to see if the client is connected to any room created and returns a boolean accordingly
	 */
	private boolean checkClient() {
		for(Room room:rooms)
			if(room.getConnectedClients().contains(this.client))
				return true;
		return false;
	}
	
	/*
	 * pre:
	 * post:This method broadcasts to all the clients in the same room as the client what the client sends to this server thread
	 */
	private void broadcast() throws IOException {
		for(Room room:rooms)
			while(room.getConnectedClients().contains(this.client)) {
				String clientMessage=this.client.getIn().readUTF();
				if(clientMessage.equalsIgnoreCase("/disconnect")) {
					room.getConnectedClients().remove(this.client);
					break;
				}
				for(ClientStorage client:room.getConnectedClients())
					client.getOut().writeUTF(clientMessage);
			}
	}
}